(function(f){var g;if(typeof window!=='undefined'){g=window}else if(typeof self!=='undefined'){g=self}g.lazyload=f()})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
module.exports = lazyload;

let inViewport = require('in-viewport');
let lazyAttrs = ['data-src'];

global.lzld = lazyload();
global.inViewport = inViewport;

// Provide libs using getAttribute early to get the good src
// and not the fake data-src
replaceGetAttribute('Image');
replaceGetAttribute('IFrame');

const registerLazyAttr = attr => {
    if (indexOf.call(lazyAttrs, attr) === -1) {
        lazyAttrs.push(attr);
    }
}

function lazyload(opts) {
    opts = merge({
        'offset': 333,
        'src': 'data-src',
        'container': false
    }, opts || {});

    if (typeof opts.src === 'string') {
        registerLazyAttr(opts.src);
    }

    let elts = [];

    const show = elt => {
        let src = findRealSrc(elt);

        if(src) {
            elt.src = src;
        }

        elt.setAttribute('data-lzled', true);
        elts[indexOf.call(elts, elt)] = null;
    }

    const findRealSrc = elt => {
        if (typeof opts.src === 'function') {
            return opts.src(elt);
        }

        return elt.getAttribute(opts.src);
    }

    const register = elt => {
        // unsubscribe onload
        // needed by IE < 9, otherwise we get another onload when changing the src
        elt.onload = null;
        elt.removeAttribute('onload');

        elt.onerror = null;
        elt.removeAttribute('onerror');

        if (indexOf.call(elts, elt) === -1) {
            inViewport(elt, opts, show);
        }
    }

    return register;
}

function replaceGetAttribute(elementName) {
    let fullname = 'HTML' + elementName + 'Element';
    if (fullname in global === false) {
        return;
    }

    let original = global[fullname].prototype.getAttribute;
    global[fullname].prototype.getAttribute = function(name) {
        if (name === 'src') {
            let realSrc;
            for (let i = 0, max = lazyAttrs.length; i < max; i++) {
                realSrc = original.call(this, lazyAttrs[i]);
                if (realSrc) {
                    break;
                }
            }

            return realSrc || original.call(this, name);
        }

        // our own lazyloader will go through theses lines
        // because we use getAttribute(opts.src)
        return original.call(this, name);
    };
}

const merge = (defaults, opts) => {
    for (let name in defaults) {
        if (typeof opts[name] === 'undefined') {
            opts[name] = defaults[name];
        }
    }

    return opts;
}

// http://webreflection.blogspot.fr/2011/06/partial-polyfills.html
const indexOf = value => {
    for (let i = this.length; i-- && this[i] !== value;) {}
    return i;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"in-viewport":2}],2:[function(require,module,exports){
(function (global){
module.exports = inViewport;

var instances = [];
var supportsMutationObserver = typeof global.MutationObserver === 'function';

function inViewport(elt, params, cb) {
  var opts = {
    container: global.document.body,
    offset: 0
  };

  if (params === undefined || typeof params === 'function') {
    cb = params;
    params = {};
  }

  var container = opts.container = params.container || opts.container;
  var offset = opts.offset = params.offset || opts.offset;

  for (var i = 0; i < instances.length; i++) {
    if (instances[i].container === container) {
      return instances[i].isInViewport(elt, offset, cb);
    }
  }

  return instances[
    instances.push(createInViewport(container)) - 1
  ].isInViewport(elt, offset, cb);
}

function addEvent(el, type, fn) {
  if (el.attachEvent) {
    el.attachEvent('on' + type, fn);
  } else {
    el.addEventListener(type, fn, false);
  }
}

function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this, args = arguments;
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);

    function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    }
  };
}

// https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708
var contains = function() {
  if (!global.document) {
    return true;
  }
  return global.document.documentElement.compareDocumentPosition ?
    function (a, b) {
      return !!(a.compareDocumentPosition(b) & 16);
    } :
    global.document.documentElement.contains ?
      function (a, b) {
        return a !== b && ( a.contains ? a.contains(b) : false );
      } :
      function (a, b) {
        while (b = b.parentNode) {
          if (b === a) {
            return true;
          }
        }
        return false;
      };
}

function createInViewport(container) {
  var watches = createWatches();

  var scrollContainer = container === global.document.body ? global : container;
  var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);

  addEvent(scrollContainer, 'scroll', debouncedCheck);

  if (scrollContainer === global) {
    addEvent(global, 'resize', debouncedCheck);
  }

  if (supportsMutationObserver) {
    observeDOM(watches, container, debouncedCheck);
  }

  // failsafe check, every 200ms we check for visible images
  // usecase: a hidden parent containing eleements
  // when the parent becomes visible, we have no event that the children
  // became visible
  setInterval(debouncedCheck, 150);

  function isInViewport(elt, offset, cb) {
    if (!cb) {
      return isVisible(elt, offset);
    }

    var remote = createRemote(elt, offset, cb);
    remote.watch();
    return remote;
  }

  function createRemote(elt, offset, cb) {
    function watch() {
      watches.add(elt, offset, cb);
    }

    function dispose() {
      watches.remove(elt);
    }

    return {
      watch: watch,
      dispose: dispose
    };
  }

  function watchInViewport(elt, offset, cb) {
    if (isVisible(elt, offset)) {
      watches.remove(elt);
      cb(elt);
    }
  }

  function isVisible(elt, offset) {
    if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {
      return false;
    }

    // Check if the element is visible
    // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js
    if (!elt.offsetWidth || !elt.offsetHeight) {
      return false;
    }

    var eltRect = elt.getBoundingClientRect();
    var viewport = {};

    if (container === global.document.body) {
      viewport = {
        top: -offset,
        left: -offset,
        right: global.document.documentElement.clientWidth + offset,
        bottom: global.document.documentElement.clientHeight + offset
      };
    } else {
      var containerRect = container.getBoundingClientRect();
      viewport = {
        top: containerRect.top - offset,
        left: containerRect.left - offset,
        right: containerRect.right + offset,
        bottom: containerRect.bottom + offset
      };
    }

    // The element must overlap with the visible part of the viewport
    var visible =
      (
        eltRect.right >= viewport.left &&
        eltRect.left <= viewport.right &&
        eltRect.bottom >= viewport.top &&
        eltRect.top <= viewport.bottom
      );

    return visible;
  }

  return {
    container: container,
    isInViewport: isInViewport
  };
}

function createWatches() {
  var watches = [];

  function add(elt, offset, cb) {
    if (!isWatched(elt)) {
      watches.push([elt, offset, cb]);
    }
  }

  function remove(elt) {
    var pos = indexOf(elt);
    if (pos !== -1) {
      watches.splice(pos, 1);
    }
  }

  function indexOf(elt) {
    for (var i = watches.length - 1; i >= 0; i--) {
      if (watches[i][0] === elt) {
        return i;
      }
    }
    return -1;
  }

  function isWatched(elt) {
    return indexOf(elt) !== -1;
  }

  function checkAll(cb) {
    return function () {
      for (var i = watches.length - 1; i >= 0; i--) {
        cb.apply(this, watches[i]);
      }
    };
  }

  return {
    add: add,
    remove: remove,
    isWatched: isWatched,
    checkAll: checkAll
  };
}

function observeDOM(watches, container, cb) {
  var observer = new MutationObserver(watch);
  var filter = Array.prototype.filter;
  var concat = Array.prototype.concat;

  observer.observe(container, {
    childList: true,
    subtree: true,
    // changes like style/width/height/display will be catched
    attributes: true
  });

  function watch(mutations) {
    // some new DOM nodes where previously watched
    // we should check their positions
    if (mutations.some(knownNodes) === true) {
      setTimeout(cb, 0);
    }
  }

  function knownNodes(mutation) {
    var nodes = concat.call([],
      Array.prototype.slice.call(mutation.addedNodes),
      mutation.target
    );
    return filter.call(nodes, watches.isWatched).length > 0;
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsYXp5bG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9pbi12aWV3cG9ydC9pbi12aWV3cG9ydC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0gbGF6eWxvYWQ7XG5cbmxldCBpblZpZXdwb3J0ID0gcmVxdWlyZSgnaW4tdmlld3BvcnQnKTtcbmxldCBsYXp5QXR0cnMgPSBbJ2RhdGEtc3JjJ107XG5cbmdsb2JhbC5semxkID0gbGF6eWxvYWQoKTtcbmdsb2JhbC5pblZpZXdwb3J0ID0gaW5WaWV3cG9ydDtcblxuLy8gUHJvdmlkZSBsaWJzIHVzaW5nIGdldEF0dHJpYnV0ZSBlYXJseSB0byBnZXQgdGhlIGdvb2Qgc3JjXG4vLyBhbmQgbm90IHRoZSBmYWtlIGRhdGEtc3JjXG5yZXBsYWNlR2V0QXR0cmlidXRlKCdJbWFnZScpO1xucmVwbGFjZUdldEF0dHJpYnV0ZSgnSUZyYW1lJyk7XG5cbmNvbnN0IHJlZ2lzdGVyTGF6eUF0dHIgPSBhdHRyID0+IHtcbiAgICBpZiAoaW5kZXhPZi5jYWxsKGxhenlBdHRycywgYXR0cikgPT09IC0xKSB7XG4gICAgICAgIGxhenlBdHRycy5wdXNoKGF0dHIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbGF6eWxvYWQob3B0cykge1xuICAgIG9wdHMgPSBtZXJnZSh7XG4gICAgICAgICdvZmZzZXQnOiAzMzMsXG4gICAgICAgICdzcmMnOiAnZGF0YS1zcmMnLFxuICAgICAgICAnY29udGFpbmVyJzogZmFsc2VcbiAgICB9LCBvcHRzIHx8IHt9KTtcblxuICAgIGlmICh0eXBlb2Ygb3B0cy5zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlZ2lzdGVyTGF6eUF0dHIob3B0cy5zcmMpO1xuICAgIH1cblxuICAgIGxldCBlbHRzID0gW107XG5cbiAgICBjb25zdCBzaG93ID0gZWx0ID0+IHtcbiAgICAgICAgbGV0IHNyYyA9IGZpbmRSZWFsU3JjKGVsdCk7XG5cbiAgICAgICAgaWYoc3JjKSB7XG4gICAgICAgICAgICBlbHQuc3JjID0gc3JjO1xuICAgICAgICB9XG5cbiAgICAgICAgZWx0LnNldEF0dHJpYnV0ZSgnZGF0YS1semxlZCcsIHRydWUpO1xuICAgICAgICBlbHRzW2luZGV4T2YuY2FsbChlbHRzLCBlbHQpXSA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZmluZFJlYWxTcmMgPSBlbHQgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMuc3JjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0cy5zcmMoZWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbHQuZ2V0QXR0cmlidXRlKG9wdHMuc3JjKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWdpc3RlciA9IGVsdCA9PiB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIG9ubG9hZFxuICAgICAgICAvLyBuZWVkZWQgYnkgSUUgPCA5LCBvdGhlcndpc2Ugd2UgZ2V0IGFub3RoZXIgb25sb2FkIHdoZW4gY2hhbmdpbmcgdGhlIHNyY1xuICAgICAgICBlbHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgZWx0LnJlbW92ZUF0dHJpYnV0ZSgnb25sb2FkJyk7XG5cbiAgICAgICAgZWx0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICBlbHQucmVtb3ZlQXR0cmlidXRlKCdvbmVycm9yJyk7XG5cbiAgICAgICAgaWYgKGluZGV4T2YuY2FsbChlbHRzLCBlbHQpID09PSAtMSkge1xuICAgICAgICAgICAgaW5WaWV3cG9ydChlbHQsIG9wdHMsIHNob3cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlR2V0QXR0cmlidXRlKGVsZW1lbnROYW1lKSB7XG4gICAgbGV0IGZ1bGxuYW1lID0gJ0hUTUwnICsgZWxlbWVudE5hbWUgKyAnRWxlbWVudCc7XG4gICAgaWYgKGZ1bGxuYW1lIGluIGdsb2JhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBvcmlnaW5hbCA9IGdsb2JhbFtmdWxsbmFtZV0ucHJvdG90eXBlLmdldEF0dHJpYnV0ZTtcbiAgICBnbG9iYWxbZnVsbG5hbWVdLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnc3JjJykge1xuICAgICAgICAgICAgbGV0IHJlYWxTcmM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbWF4ID0gbGF6eUF0dHJzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVhbFNyYyA9IG9yaWdpbmFsLmNhbGwodGhpcywgbGF6eUF0dHJzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhbFNyYykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWFsU3JjIHx8IG9yaWdpbmFsLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdXIgb3duIGxhenlsb2FkZXIgd2lsbCBnbyB0aHJvdWdoIHRoZXNlcyBsaW5lc1xuICAgICAgICAvLyBiZWNhdXNlIHdlIHVzZSBnZXRBdHRyaWJ1dGUob3B0cy5zcmMpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIH07XG59XG5cbmNvbnN0IG1lcmdlID0gKGRlZmF1bHRzLCBvcHRzKSA9PiB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcHRzW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0cztcbn1cblxuLy8gaHR0cDovL3dlYnJlZmxlY3Rpb24uYmxvZ3Nwb3QuZnIvMjAxMS8wNi9wYXJ0aWFsLXBvbHlmaWxscy5odG1sXG5jb25zdCBpbmRleE9mID0gdmFsdWUgPT4ge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aDsgaS0tICYmIHRoaXNbaV0gIT09IHZhbHVlOykge31cbiAgICByZXR1cm4gaTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW5WaWV3cG9ydDtcblxudmFyIGluc3RhbmNlcyA9IFtdO1xudmFyIHN1cHBvcnRzTXV0YXRpb25PYnNlcnZlciA9IHR5cGVvZiBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gaW5WaWV3cG9ydChlbHQsIHBhcmFtcywgY2IpIHtcbiAgdmFyIG9wdHMgPSB7XG4gICAgY29udGFpbmVyOiBnbG9iYWwuZG9jdW1lbnQuYm9keSxcbiAgICBvZmZzZXQ6IDBcbiAgfTtcblxuICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gcGFyYW1zO1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyID0gcGFyYW1zLmNvbnRhaW5lciB8fCBvcHRzLmNvbnRhaW5lcjtcbiAgdmFyIG9mZnNldCA9IG9wdHMub2Zmc2V0ID0gcGFyYW1zLm9mZnNldCB8fCBvcHRzLm9mZnNldDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbnN0YW5jZXNbaV0uY29udGFpbmVyID09PSBjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZXNbaV0uaXNJblZpZXdwb3J0KGVsdCwgb2Zmc2V0LCBjYik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlc1tcbiAgICBpbnN0YW5jZXMucHVzaChjcmVhdGVJblZpZXdwb3J0KGNvbnRhaW5lcikpIC0gMVxuICBdLmlzSW5WaWV3cG9ydChlbHQsIG9mZnNldCwgY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudChlbCwgdHlwZSwgZm4pIHtcbiAgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gIHZhciB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIGlmIChjYWxsTm93KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXG4gICAgZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvYmxvYi8zMTM2ZjQ4YjkwZTNlZGM4NGNiYWFhNmY2Zjc3MzRlZjAzNzc1YTA3L3NpenpsZS5qcyNMNzA4XG52YXIgY29udGFpbnMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/XG4gICAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiAhIShhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgMTYpO1xuICAgIH0gOlxuICAgIGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgP1xuICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKCBhLmNvbnRhaW5zID8gYS5jb250YWlucyhiKSA6IGZhbHNlICk7XG4gICAgICB9IDpcbiAgICAgIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHdoaWxlIChiID0gYi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgaWYgKGIgPT09IGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJblZpZXdwb3J0KGNvbnRhaW5lcikge1xuICB2YXIgd2F0Y2hlcyA9IGNyZWF0ZVdhdGNoZXMoKTtcblxuICB2YXIgc2Nyb2xsQ29udGFpbmVyID0gY29udGFpbmVyID09PSBnbG9iYWwuZG9jdW1lbnQuYm9keSA/IGdsb2JhbCA6IGNvbnRhaW5lcjtcbiAgdmFyIGRlYm91bmNlZENoZWNrID0gZGVib3VuY2Uod2F0Y2hlcy5jaGVja0FsbCh3YXRjaEluVmlld3BvcnQpLCAxNSk7XG5cbiAgYWRkRXZlbnQoc2Nyb2xsQ29udGFpbmVyLCAnc2Nyb2xsJywgZGVib3VuY2VkQ2hlY2spO1xuXG4gIGlmIChzY3JvbGxDb250YWluZXIgPT09IGdsb2JhbCkge1xuICAgIGFkZEV2ZW50KGdsb2JhbCwgJ3Jlc2l6ZScsIGRlYm91bmNlZENoZWNrKTtcbiAgfVxuXG4gIGlmIChzdXBwb3J0c011dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlRE9NKHdhdGNoZXMsIGNvbnRhaW5lciwgZGVib3VuY2VkQ2hlY2spO1xuICB9XG5cbiAgLy8gZmFpbHNhZmUgY2hlY2ssIGV2ZXJ5IDIwMG1zIHdlIGNoZWNrIGZvciB2aXNpYmxlIGltYWdlc1xuICAvLyB1c2VjYXNlOiBhIGhpZGRlbiBwYXJlbnQgY29udGFpbmluZyBlbGVlbWVudHNcbiAgLy8gd2hlbiB0aGUgcGFyZW50IGJlY29tZXMgdmlzaWJsZSwgd2UgaGF2ZSBubyBldmVudCB0aGF0IHRoZSBjaGlsZHJlblxuICAvLyBiZWNhbWUgdmlzaWJsZVxuICBzZXRJbnRlcnZhbChkZWJvdW5jZWRDaGVjaywgMTUwKTtcblxuICBmdW5jdGlvbiBpc0luVmlld3BvcnQoZWx0LCBvZmZzZXQsIGNiKSB7XG4gICAgaWYgKCFjYikge1xuICAgICAgcmV0dXJuIGlzVmlzaWJsZShlbHQsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgdmFyIHJlbW90ZSA9IGNyZWF0ZVJlbW90ZShlbHQsIG9mZnNldCwgY2IpO1xuICAgIHJlbW90ZS53YXRjaCgpO1xuICAgIHJldHVybiByZW1vdGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZW1vdGUoZWx0LCBvZmZzZXQsIGNiKSB7XG4gICAgZnVuY3Rpb24gd2F0Y2goKSB7XG4gICAgICB3YXRjaGVzLmFkZChlbHQsIG9mZnNldCwgY2IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB3YXRjaGVzLnJlbW92ZShlbHQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3YXRjaDogd2F0Y2gsXG4gICAgICBkaXNwb3NlOiBkaXNwb3NlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhdGNoSW5WaWV3cG9ydChlbHQsIG9mZnNldCwgY2IpIHtcbiAgICBpZiAoaXNWaXNpYmxlKGVsdCwgb2Zmc2V0KSkge1xuICAgICAgd2F0Y2hlcy5yZW1vdmUoZWx0KTtcbiAgICAgIGNiKGVsdCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNWaXNpYmxlKGVsdCwgb2Zmc2V0KSB7XG4gICAgaWYgKCFjb250YWlucyhnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBlbHQpIHx8ICFjb250YWlucyhnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBjb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvNzQwZTE5MDIyM2QxOWExMTRkNTM3Mzc1ODEyNzI4NWQxNGQ2YjcxZS9zcmMvY3NzL2hpZGRlblZpc2libGVTZWxlY3RvcnMuanNcbiAgICBpZiAoIWVsdC5vZmZzZXRXaWR0aCB8fCAhZWx0Lm9mZnNldEhlaWdodCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlbHRSZWN0ID0gZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciB2aWV3cG9ydCA9IHt9O1xuXG4gICAgaWYgKGNvbnRhaW5lciA9PT0gZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcbiAgICAgIHZpZXdwb3J0ID0ge1xuICAgICAgICB0b3A6IC1vZmZzZXQsXG4gICAgICAgIGxlZnQ6IC1vZmZzZXQsXG4gICAgICAgIHJpZ2h0OiBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0LFxuICAgICAgICBib3R0b206IGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZpZXdwb3J0ID0ge1xuICAgICAgICB0b3A6IGNvbnRhaW5lclJlY3QudG9wIC0gb2Zmc2V0LFxuICAgICAgICBsZWZ0OiBjb250YWluZXJSZWN0LmxlZnQgLSBvZmZzZXQsXG4gICAgICAgIHJpZ2h0OiBjb250YWluZXJSZWN0LnJpZ2h0ICsgb2Zmc2V0LFxuICAgICAgICBib3R0b206IGNvbnRhaW5lclJlY3QuYm90dG9tICsgb2Zmc2V0XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRoZSBlbGVtZW50IG11c3Qgb3ZlcmxhcCB3aXRoIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlIHZpZXdwb3J0XG4gICAgdmFyIHZpc2libGUgPVxuICAgICAgKFxuICAgICAgICBlbHRSZWN0LnJpZ2h0ID49IHZpZXdwb3J0LmxlZnQgJiZcbiAgICAgICAgZWx0UmVjdC5sZWZ0IDw9IHZpZXdwb3J0LnJpZ2h0ICYmXG4gICAgICAgIGVsdFJlY3QuYm90dG9tID49IHZpZXdwb3J0LnRvcCAmJlxuICAgICAgICBlbHRSZWN0LnRvcCA8PSB2aWV3cG9ydC5ib3R0b21cbiAgICAgICk7XG5cbiAgICByZXR1cm4gdmlzaWJsZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgaXNJblZpZXdwb3J0OiBpc0luVmlld3BvcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcygpIHtcbiAgdmFyIHdhdGNoZXMgPSBbXTtcblxuICBmdW5jdGlvbiBhZGQoZWx0LCBvZmZzZXQsIGNiKSB7XG4gICAgaWYgKCFpc1dhdGNoZWQoZWx0KSkge1xuICAgICAgd2F0Y2hlcy5wdXNoKFtlbHQsIG9mZnNldCwgY2JdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoZWx0KSB7XG4gICAgdmFyIHBvcyA9IGluZGV4T2YoZWx0KTtcbiAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgd2F0Y2hlcy5zcGxpY2UocG9zLCAxKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRleE9mKGVsdCkge1xuICAgIGZvciAodmFyIGkgPSB3YXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAod2F0Y2hlc1tpXVswXSA9PT0gZWx0KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBpc1dhdGNoZWQoZWx0KSB7XG4gICAgcmV0dXJuIGluZGV4T2YoZWx0KSAhPT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0FsbChjYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gd2F0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjYi5hcHBseSh0aGlzLCB3YXRjaGVzW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZGQ6IGFkZCxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICBpc1dhdGNoZWQ6IGlzV2F0Y2hlZCxcbiAgICBjaGVja0FsbDogY2hlY2tBbGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZURPTSh3YXRjaGVzLCBjb250YWluZXIsIGNiKSB7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHdhdGNoKTtcbiAgdmFyIGZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXI7XG4gIHZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyLCB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgLy8gY2hhbmdlcyBsaWtlIHN0eWxlL3dpZHRoL2hlaWdodC9kaXNwbGF5IHdpbGwgYmUgY2F0Y2hlZFxuICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gd2F0Y2gobXV0YXRpb25zKSB7XG4gICAgLy8gc29tZSBuZXcgRE9NIG5vZGVzIHdoZXJlIHByZXZpb3VzbHkgd2F0Y2hlZFxuICAgIC8vIHdlIHNob3VsZCBjaGVjayB0aGVpciBwb3NpdGlvbnNcbiAgICBpZiAobXV0YXRpb25zLnNvbWUoa25vd25Ob2RlcykgPT09IHRydWUpIHtcbiAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGtub3duTm9kZXMobXV0YXRpb24pIHtcbiAgICB2YXIgbm9kZXMgPSBjb25jYXQuY2FsbChbXSxcbiAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG11dGF0aW9uLmFkZGVkTm9kZXMpLFxuICAgICAgbXV0YXRpb24udGFyZ2V0XG4gICAgKTtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwobm9kZXMsIHdhdGNoZXMuaXNXYXRjaGVkKS5sZW5ndGggPiAwO1xuICB9XG59XG4iXX0=
